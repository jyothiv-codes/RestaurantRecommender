# -*- coding: utf-8 -*-
"""CS276-Project-CollaborativeFiltering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N8aVYzOEN_iZ6vsO6gCllJcdkO-AXOeJ
"""

from google.colab import drive
drive.mount('/content/drive')

"""# ***Using Tensorflow***"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import Dense, Embedding, Input, Concatenate
import pandas as pd
import numpy as np

# Load data
data_initial = pd.read_csv('/content/drive/MyDrive/restaurant-ratings.csv',nrows=100)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics.pairwise import cosine_similarity

# Sample dataset similar to the Yelp dataset
data = {
    'user_id': [1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 10],
    'restaurant_id': [101, 102, 103, 101, 102, 102, 103, 104, 105, 105, 101, 101, 102, 103, 103, 101, 104, 105, 104, 104, 103, 102, 101, 101, 102],
    'rating': [5, 4, 3, 4, 5, 1, 2, 4, 3, 5, 4, 5, 3, 2, 1, 5, 5, 4, 4, 3, 3, 4, 2, 1, 4],
}

df = pd.DataFrame(data)

# Create a user-restaurant matrix
user_restaurant_matrix = df.pivot_table(index='user_id', columns='restaurant_id', values='rating', fill_value=0)

train_data, test_data = train_test_split(df, test_size=0.2, random_state=42)


train_user_restaurant_matrix = train_data.pivot_table(index='user_id', columns='restaurant_id', values='rating', fill_value=0)

#calculate user similarities
user_similarities = cosine_similarity(train_user_restaurant_matrix)

#recommend restaurants for a user
def recommend_restaurants(user_id, num_recommendations=5):
    if user_id not in user_restaurant_matrix.index:
        print(f"User {user_id} not found")
        return []

    user_ratings = user_restaurant_matrix.loc[user_id]
    similar_users_indices = user_similarities[user_id - 1].argsort()[::-1][1:]  # Exclude the user itself

    recommendations = []
    for restaurant_id in user_restaurant_matrix.columns:
        if user_ratings[restaurant_id] == 0:  # Check if the restaurant hasn't been rated by the user
            weighted_sum = 0
            similarity_sum = 0

            for other_user_index in similar_users_indices:
                other_user_rating = user_restaurant_matrix.iloc[other_user_index][restaurant_id]
                other_user_similarity = user_similarities[user_id - 1][other_user_index]

                weighted_sum += other_user_rating * other_user_similarity
                similarity_sum += abs(other_user_similarity)

            if similarity_sum > 0:
                predicted_rating = weighted_sum / similarity_sum
                recommendations.append((restaurant_id, predicted_rating))

    # sort by predicted rating
    recommendations.sort(key=lambda x: x[1], reverse=True)

    # fetch the top recommended restaurants
    top_recommendations = [restaurant_id for restaurant_id, rec in recommendations[:num_recommendations]]

    return top_recommendations

user_id_to_recommend = 1
recommended_restaurants = recommend_restaurants(user_id_to_recommend, num_recommendations=2)

print("Top recommended restaurants for user: ",user_id_to_recommend)
for restaurant_id in recommended_restaurants:
    print("Restaurant ID: ",restaurant_id)


user_id_to_recommend = 3
recommended_restaurants = recommend_restaurants(user_id_to_recommend, num_recommendations=3)

print("Top recommended restaurants for user: ",user_id_to_recommend)
for restaurant_id in recommended_restaurants:
    print("Restaurant ID: ",restaurant_id)

# Calculate predicted ratings
test_users=[1,2,3]
test_restaurants=[101, 102, 103]
test_actual_ratings=[5,5,2]
predicted_ratings = []
for i in range(len(test_users)):
    user_id = test_users[i]
    restaurant_id = test_restaurants[i]
    recommendations = recommend_restaurants(user_id)
    predicted_rating = 0
    for recommendation in recommendations:
        if recommendation == restaurant_id:
            predicted_rating = recommendation[1]
            break
    predicted_ratings.append(predicted_rating)

# Calculate MAE
mae = 0
for i in range(len(test_actual_ratings)):
    mae += abs(test_actual_ratings[i] - predicted_ratings[i])
mae /= len(test_actual_ratings)

print("MAE:", mae)